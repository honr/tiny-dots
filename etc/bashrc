#!/bin/bash

# On linux: "linux", on Mac OS X: "darwin".
UNAME="$(uname)"
case "$UNAME" in
  Linux) UNAME=linux ;;
  Darwin) UNAME=darwin ;;
esac

# TODO: Add a compilation function (to pool.manage) that recreates .bashrc
# from all these sources.  The corresponding .book line could look like:
# build "clj/project.clj" to "~/.local/share/java/project.clj"
#
# TODO: Do not source the same source again.  An associative array would have
# helped if it was available in bash 3.
function source_maybe () {
  local filename="$1"
  local name="$2"
  local was_sourced="bash_sourced_$name"
  if [ -z "${!was_sourced}" -a -r "$filename" ] ; then
      source "$filename"
      declare -g "bash_sourced_$name"=t
  fi
}

source_maybe ~/.local/lib/bash/path.$UNAME path_UNAME

# If not running interactively, don't do anything.
[ -z "$PS1" ] && return

source_maybe ~/.local/lib/bash/term.bash term_bash
source_maybe ~/.local/lib/bash/term.$UNAME term_UNAME
source_maybe ~/.local/lib/bash/generic.clj.bash generic_clj
source_maybe ~/.local/lib/bash/alias.bash alias_bash
source_maybe ~/.local/lib/bash/alias.$UNAME alias_UNAME
source_maybe ~/.local/lib/bash/util.bash util_bash

export PROMPT_COMMAND="prompt-update"
prepare-for-prompt-update-ps1
function prompt-update () {
  history -a
  prompt-update-ps1
}

source_maybe ~/.local/lib/bash/site-local.bash site_local_bash
source_maybe ~/.local/lib/bash/host-local.bash host_local_bash
